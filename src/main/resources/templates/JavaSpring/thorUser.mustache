/**
 * {@link {{classname}}}}.
 *
 *
 {{#description}}{{.}}{{/description}}{{^description}}{{classname}}{{/description}}
 ############################## DO NOT EDIT: GENERATED FILE ##############################

    Generated by Valkyr Labs ThorAPI: https://valkyrlabs.com/thorapi
    Powered by Swagger Codegen: http://swagger.io
    
    Template file: JavaSpring/thorUser.mustache

############################## DO NOT EDIT: GENERATED FILE ##############################
 #
 * Do not edit the class manually.
 */
package {{modelPackage}};

import {{apiPackage}}.*;
{{#imports}}import {{import}};
{{/imports}}


import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.CredentialsContainer;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.SpringSecurityCoreVersion;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.beans.BeanUtils;
import com.valkyrlabs.api.ThorGrantedAuthority;

/**
 * SYSTEM USER UserDetails wrapper for a Principal
 *
 * Note that this implementation is not immutable. It implements the
 * {@code CredentialsContainer} interface, in order to allow the password to be
 * erased after authentication. This may cause side-effects if you are storing
 * instances in-memory and reusing them. If so, make sure you return a copy from
 * your {@code UserDetailsService} each time it is invoked.
 * @param <Authority>
 *
 */
public final class ThorUser<Authority> extends Principal implements UserDetails, CredentialsContainer {

	private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;
	protected static final Logger logger = LoggerFactory.getLogger(ThorUser.class);


	private UUID ownerId = null;

	public void setOwnerId(UUID oid){
		this.ownerId = oid;
	}
	
	public ThorUser(){
		super();
	}

	public ThorUser(Principal p){
		BeanUtils.copyProperties(p, this);
	}

	public List<GrantedAuthority> convertAuthoritiesToGrantedAuthorities(
			List<com.valkyrlabs.model.Authority> authorities) {
		List<GrantedAuthority> authorityList = new ArrayList<>();
		if (authorities == null) {
			authorities = getAuthorityList();
		}

		for (com.valkyrlabs.model.Authority a : authorities) {
			GrantedAuthority auth = (GrantedAuthority) () -> a.getAuthority();
			authorityList.add(auth);
		}
		return authorityList;
	}

	public void copyValuesFromPrincipal(Principal principal) {
		this.setId(principal.getId());
		this.setUsername(principal.getUsername());
		this.setPassword(principal.getPassword());
		this.setAuthorityList(principal.getAuthorityList());
		this.setAccountNonExpired(principal.getAccountNonExpired());
		this.setAccountNonLocked(principal.getAccountNonLocked());
		this.setCredentialNonExpired(principal.getCredentialNonExpired());
		this.setEnabled(principal.getEnabled());
	}

	public void copyValuesFromUserDetails(UserDetails principal) {

		this.setUsername(principal.getUsername());
		this.setPassword(principal.getPassword());
		// this.setId(principal.getId());
		Collection<? extends GrantedAuthority> authorities = principal.getAuthorities();
		List<com.valkyrlabs.model.Authority> authorityList = new ArrayList();
		for (GrantedAuthority a : authorities) {
			com.valkyrlabs.model.Authority auth = (com.valkyrlabs.model.Authority) new com.valkyrlabs.model.Authority().authority(a.getAuthority());
			authorityList.add(auth);
		}
		this.setAuthorityList(authorityList);
		this.setAccountNonExpired(principal.isAccountNonExpired());
		this.setAccountNonLocked(principal.isAccountNonLocked());
		this.setCredentialNonExpired(principal.isCredentialsNonExpired());
		this.setEnabled(principal.isEnabled());

	}

	public Collection<GrantedAuthority> getAuthorities() {
		// convert to
		Collection<GrantedAuthority> returnlist = new ArrayList<GrantedAuthority>();
		List<com.valkyrlabs.model.Authority> authorities = super.getAuthorityList();
		for (com.valkyrlabs.model.Authority auth : authorities) {
			logger.trace("initializing Authority: {}", auth);
			returnlist.add((GrantedAuthority) new ThorGrantedAuthority(auth));
		}
		return returnlist;
	}

	public void eraseCredentials() {
		logger.info("Erase Credentials called on: " + this.toString());
		this.setPassword(null);

		// this.setAuthorities(null);
		// this.setCredentials(null);
		// TOOD: persist?
	}

	/**
	 * Indicates whether the user's account has expired. An expired account cannot
	 * be authenticated.
	 * 
	 * @return <code>true</code> if the user's account is valid (ie non-expired),
	 *         <code>false</code> if no longer valid (ie expired)
	 */
	@Override
	public boolean isAccountNonExpired() {
		return this.getAccountNonExpired();
	}

	/**
	 * Indicates whether the user is locked or unlocked. A locked user cannot be
	 * authenticated.
	 * 
	 * @return <code>true</code> if the user is not locked, <code>false</code>
	 *         otherwise
	 */
	@Override
	public boolean isAccountNonLocked() {
		return this.getAccountNonLocked();
	}

	/**
	 * Indicates whether the user's credentials (password) has expired. Expired
	 * credentials prevent authentication.
	 * 
	 * @return <code>true</code> if the user's credentials are valid (ie
	 *         non-expired), <code>false</code> if no longer valid (ie expired)
	 */
	@Override
	public boolean isCredentialsNonExpired() {
		return this.getCredentialNonExpired();
	}

	/**
	 * Indicates whether the user is enabled or disabled. A disabled user cannot be
	 * authenticated.
	 * 
	 * @return <code>true</code> if the user is enabled, <code>false</code>
	 *         otherwise
	 */
	@Override
	public boolean isEnabled() {
		return this.getEnabled();
	}

	public Set<GrantedAuthority> sortAuthorities(Set<GrantedAuthority> authorities) {
		logger.info("TODO: SANITIZE AUHTORITIES {} AND VALIDATE AGAINST KNOWN LIST", authorities.toString());
		if (getAuthorities() == null) {
			logger.warn("Attempting to sort a null Authority List. Skipping");
			return null;
		} // Ensure array iteration order is predictable
		SortedSet<GrantedAuthority> sortedAuthorities = new TreeSet<>(new AuthorityComparator());
		for (GrantedAuthority grantedAuthority : authorities) {

			if (grantedAuthority == null) {
				logger.error("GrantedAuthority list cannot contain any null elements");
			} else {
				logger.trace("Adding {} to GrantedAuthority list.", grantedAuthority);
				sortedAuthorities.add(grantedAuthority);
			}
		}
		return sortedAuthorities;
	}

	/**
	 * Returns {@code true} if the supplied object is a {@code Principal} instance
	 * with the same {@code username} value.
	 * <p>
	 * In other words, the objects are equal if they have the same username,
	 * representing the same principal.
	 */
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof ThorUser) {
			return getUsername().equals(((ThorUser) obj).getUsername());
		}
		return false;
	}

	private static class AuthorityComparator implements Comparator<GrantedAuthority>, Serializable {

		private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;

		@Override
		public int compare(GrantedAuthority g1, GrantedAuthority g2) {
			// Neither should ever be null as each entry is checked before adding it to
			// the set. If the authority is null, it is a custom authority and should
			// precede others.
			if (g2.getAuthority() == null) {
				return -1;
			}
			if (g1.getAuthority() == null) {
				return 1;
			}
			return g1.getAuthority().compareTo(g2.getAuthority());
		}
	}
}
